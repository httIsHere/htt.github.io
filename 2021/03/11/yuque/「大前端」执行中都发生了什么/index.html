<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="referrer" content="no-referrer" />

    <meta name="author" content="httishere">





<title>「大前端」执行中都发生了什么 | HTTISHERE</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.2.0"></head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">HTTISHERE&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">HTTISHERE&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">「大前端」执行中都发生了什么</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">httishere</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">三月 11, 2021&nbsp;&nbsp;14:03:37</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Javascript/">Javascript</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="Promise-or-setTimeOut"><a href="#Promise-or-setTimeOut" class="headerlink" title="Promise or setTimeOut"></a>Promise or setTimeOut</h2><p>得到一段 JS 代码时，浏览器或者 Node 环境首先要做的就是；传递给 JavaScript 引擎，并且要求它去执行。但是宿主环境当遇到一些事件时，会继续把一段代码传递给 JavaScript 引擎去执行。可能还会提供 API 给 JavaScript 引擎，比如 setTimeout 这样的 API，它会允许 JavaScript 在特定的时机执行。</p>
<p>一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。</p>
<p>在 ES5 之后，JavaScript 引入了 Promise，这样不需要浏览器的安排，JavaScript 引擎本身也可以发起任务了（宿主发起的任务称之为：<strong>宏任务</strong>，JS 引擎发起的任务称之为：<strong>微任务</strong>）。</p>
<p>_相关：_【面试】什么是宏观任务？ 什么是微观任务？ 为什么会有宏观任务和微观任务？ JS 代码如何被执行？</p>
<h3 id="宏观和微观任务"><a href="#宏观和微观任务" class="headerlink" title="宏观和微观任务"></a>宏观和微观任务</h3><p>JavaScript 引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在 Node 术语中，也会把这个部分称为事件循环。</p>
<p>整个循环做的事情基本上就是反复“等待 - 执行”，实际中还有要判断循环是否结束、宏观任务队列等逻辑。</p>
<p>所以<strong>宏观任务的队列就相当于事件循环</strong>。</p>
<p>在宏观任务中，JavaScript 的 Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/250093/1615442641602-3651867b-6319-491c-a2fc-de436e5a69d1.jpeg#align=left&display=inline&height=1636&margin=%5Bobject%20Object%5D&originHeight=1636&originWidth=1398&size=0&status=done&style=none&width=1398"></p>
<blockquote>
<p>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么 JavaScript 不能有多个线程呢 ？这样能提高效率啊。 JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>
</blockquote>
<p>有了宏观任务和微观任务机制，我们就可以实现 JavaScript 引擎级和宿主级的任务了，例如：Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务。</p>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><blockquote>
<p>Promise 是 JavaScript 语言提供的一种标准化的异步管理方式，它的总体思想是，需要进行 io、等待或者其它异步操作的函数，不返回真实结果，而返回一个“承诺”，函数的调用方可以在合适的时机，选择等待这个承诺兑现（通过 Promise 的 then 方法的回调）。</p>
</blockquote>
<p>基本使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;finished&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><em>例 1</em> Promise 函数内的执行顺序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  resolve(); <span class="comment">// 就是调用时的then函数</span></span><br><span class="line">&#125;);</span><br><span class="line">r.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">// a b c</span></span><br></pre></td></tr></table></figure>

<p>Promise 的 resolve 始终是异步操作，所以 c 无法出现在 b 之前。</p>
<p><em>例 2</em> setTimeOut 和 Promise 混合：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;d&quot;</span>), <span class="number">0</span>);</span><br><span class="line">r.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">// a b c d</span></span><br></pre></td></tr></table></figure>

<p>Promise 产生的是 JavaScript 引擎内部的微任务，而 setTimeout 是浏览器 API，它产生宏任务，<strong>微任务始终先于宏任务</strong>（因为微观服务是包含在宏观服务中）。</p>
<p><em>例 3</em> 微任务优先于宏任务：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;d&quot;</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line">r.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> begin = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() - begin &lt; <span class="number">1000</span>); <span class="comment">// 执行一个耗时 1 秒的 Promise</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;c1&quot;</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;c2&quot;</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// c1 c2 d</span></span><br></pre></td></tr></table></figure>

<p>设置 1 秒延时，确保任务 c2 是在 d 之后被添加到任务队列，所以可以得出微任务优先的结论。</p>
<p><strong>分析异步执行的顺序：</strong></p>
<ul>
<li>首先我们分析有多少个宏任务；</li>
<li>在每个宏任务中，分析有多少个微任务；</li>
<li>根据调用次序，确定宏任务中的微任务执行次序；</li>
<li>根据宏任务的触发规则和调用次序，确定宏任务的执行次序；</li>
<li>确定整个顺序。</li>
</ul>
<p><em>例 4</em> 复杂的顺序问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">sleep(<span class="number">5000</span>).then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"><span class="comment">// a b c</span></span><br></pre></td></tr></table></figure>

<p>利用 Promise 把 setTimeout 封装成可以用于异步的函数，setTimeout 把整个代码分割成了 2 个宏观任务：</p>
<ul>
<li>第一个宏观任务中，包含了先后同步执行的 console.log(“a”); 和 console.log(“b”)；</li>
<li>setTimeout 后，第二个宏观任务执行调用了 resolve，然后 then 中的代码异步得到执行，所以调用了 console.log(“c”)；</li>
</ul>
<h3 id="新特性：async-await"><a href="#新特性：async-await" class="headerlink" title="新特性：async/await"></a>新特性：async/await</h3><p>它提供了用 for、if 等代码结构来编写异步的方式。它的运行时基础是 Promise。</p>
<p>async 函数必定返回 Promise，我们把所有返回 Promise 的函数都可以认为是异步函数。</p>
<p>async 函数是一种特殊语法，特征是在 function 关键字之前加上 async 关键字，这样，就定义了一个 async 函数，我们可以在其中使用 await 来等待一个 Promise。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">2000</span>); <span class="comment">// await 会等待一个Promise后继续执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// after 2s</span></span><br><span class="line"><span class="comment">// b</span></span><br></pre></td></tr></table></figure>

<p>async 函数可以嵌套，我们在定义了一批原子操作的情况下，可以利用 async 函数组合出新的 async 函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> foo(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> foo(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo2();</span><br><span class="line"><span class="comment">// after 2s</span></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// after 2s</span></span><br><span class="line"><span class="comment">// b</span></span><br></pre></td></tr></table></figure>

<p>foo2 用 await 调用了两次异步函数 foo。</p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。许多的微观任务的队列组成了宏观任务。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>实现一个红绿灯，把一个圆形 div 按照绿色 3 秒，黄色 1 秒，红色 2 秒循环改变背景色。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  changeColor(<span class="string">&quot;green&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">3000</span>);</span><br><span class="line">  changeColor(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">  changeColor(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> color = <span class="string">&quot;green&quot;</span>;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 实现一个循环执行后执行</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> func();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">main();</span><br></pre></td></tr></table></figure>

<h2 id="闭包-amp-执行上下文"><a href="#闭包-amp-执行上下文" class="headerlink" title="闭包 &amp; 执行上下文"></a>闭包 &amp; 执行上下文</h2><p>JavaScript 执行中最粗粒度的任务：传给引擎执行的代码段。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/250093/1615442641578-5775739e-90d3-49da-bbd8-6e03dfc63e02.png#align=left&display=inline&height=481&margin=%5Bobject%20Object%5D&originHeight=481&originWidth=745&size=0&status=done&style=none&width=745"></p>
<h3 id="闭包（closure）"><a href="#闭包（closure）" class="headerlink" title="闭包（closure）"></a>闭包（closure）</h3><p>闭包其实只是一个<strong>绑定了执行环境</strong>的<strong>函数</strong>，它携带了执行的环境。</p>
<p>根据古典定义，闭包组成部分：</p>
<ul>
<li>环境部分环境：<ul>
<li>函数的词法环境（执行上下文的一部分）</li>
<li>标识符列表：函数中用到的未声明的</li>
</ul>
</li>
<li>变量表达式部分：函数体</li>
</ul>
<p>所以 JavaScript 中的函数完全符合闭包的定义。它的环境部分是函数词法环境部分组成，它的标识符列表是函数中用到的未声明变量，它的表达式部分就是函数体。</p>
<p>JavaScript 中跟闭包对应的概念就是“函数”，而非作用域。</p>
<p>从广泛的角度说，普通函数就属于闭包，但这对于我们真正理解闭包毫无意义。真正的闭包应该是即使函数是在当前词法作用域之外执行，仍访问到函数内部属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line">baz(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="执行上下文：执行的基础设施"><a href="#执行上下文：执行的基础设施" class="headerlink" title="执行上下文：执行的基础设施"></a>执行上下文：执行的基础设施</h3><p>JavaScript 函数的主要复杂性来自于它携带的“环境部分”，JavaScript 标准把一段代码（包括函数），<em>执行所需的所有信息</em>定义为：“执行上下文”。</p>
<p><strong>执行上下文在 ES3 中</strong>，包含三个部分：</p>
<ul>
<li>scope：作用域，也常常被叫做作用域链。</li>
<li>variable object：变量对象，用于存储变量的对象。</li>
<li>this value：this 值。</li>
</ul>
<p><strong>在 ES5 中</strong>，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子：</p>
<ul>
<li>lexical environment：词法环境，当获取变量时使用。</li>
<li>variable environment：变量环境，当声明变量时使用。</li>
<li>this value：this 值。</li>
</ul>
<p><strong>在 ES2018 中</strong>（<strong><em>推荐</em></strong>），执行上下文又变成了这个样子，this 值被归入 lexical environment：</p>
<ul>
<li>lexical environment：词法环境，当获取变量或者 this 值时使用。</li>
<li>variable environment：变量环境，当声明变量时使用。</li>
<li>code evaluation state：用于恢复代码执行位置。</li>
<li>Function：执行的任务是函数时使用，表示正在被执行的函数。</li>
<li>ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。</li>
<li>Realm：使用的基础库和内置对象实例。</li>
<li>Generator：仅生成器上下文有这个属性，表示当前生成器。</li>
</ul>
<h4 id="var-声明与赋值"><a href="#var-声明与赋值" class="headerlink" title="var 声明与赋值"></a>var 声明与赋值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>var 声明作用于函数执行的作用域，也就是说，var 会穿透 for 、if 等语句。</p>
<p>在还没有 let 的时候–立即执行的函数表达式（<strong>立即执行函数，IIFE</strong>），通过创建一个函数，并且立即执行，来构造一个新的域，从而控制 var 的范围。</p>
<p><em>例 1</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="comment">//code</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="comment">//code</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用void关键字，代替立即执行函数包在外边的括号</span></span><br><span class="line"><span class="comment">// 可以避免前一行代码不带分号而带来的问题</span></span><br><span class="line"><span class="keyword">void</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="comment">//code</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>_例 2_，有时候 var 的特性会导致声明的变量和被赋值的变量是两个 b：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"><span class="keyword">void</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> env = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line">  b = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;In function b:&quot;</span>, b);</span><br><span class="line">  <span class="keyword">with</span> (env) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;In with b:&quot;</span>, b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Global b:&quot;</span>, b);</span><br><span class="line"><span class="comment">// In function b:2</span></span><br><span class="line"><span class="comment">// In with b:3</span></span><br><span class="line"><span class="comment">// Global b:undefined</span></span><br></pre></td></tr></table></figure>

<p>在 Global function with 三个环境中，b 的值都不一样，而在 function 环境中，并没有出现 var b，这说明 with 内的 var b 作用到了 function 这个环境当中（with 内的 var b 得到了变量提升），所以并未改变 Global 环境内的 b。</p>
<p>所以 with 内的 b 对 Function 和 With 两个域都起了作用，所以不推荐使用 with。</p>
<h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>ES6 开始引入的新的变量声明模式，在 let 出现之前，JavaScript 的 if for 等语句皆不产生作用域。</p>
<p>会产生 let 使用的作用域：</p>
<ul>
<li>for；</li>
<li>if；</li>
<li>switch；</li>
<li>try/catch/finally。</li>
</ul>
<h4 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h4><p>在实际的前端开发中，通过 iframe 等方式创建多 window 环境并非罕见的操作，所以，这才促成了新概念 Realm 的引入。</p>
<p>Realm 中包含一组完整的内置对象，而且是复制关系，顶层对象的复制关系，原型是互不干涉的。</p>
<p>在浏览器环境中获取来自两个 Realm 的对象，它们跟本土的 Object 做 instanceOf 时会产生差异：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.documentElement.appendChild(iframe);</span><br><span class="line">iframe.src = <span class="string">&quot;javascript:var b = &#123;&#125;;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = iframe.contentWindow.b;</span><br><span class="line"><span class="keyword">var</span> b2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b1, <span class="keyword">typeof</span> b2); <span class="comment">//object object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>, b2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//false true</span></span><br></pre></td></tr></table></figure>

<p>由于 b1、 b2 由同样的代码“ {} ”在不同的 Realm 中执行，所以表现出了不同的行为。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>上述我们了解了执行上下文是什么（JavaScript 标准把一段代码（包括函数），<em>执行所需的所有信息</em>定义为：“执行上下文”。），也知道了任何语句的执行都会依赖特定的上下文。</p>
<p>切换上下文最主要的场景是函数调用。</p>
<p>类型：</p>
<ul>
<li>普通函数：function 关键字定义的函数，<code>function foo()&#123;&#125;</code>；</li>
<li>箭头函数：=&gt;运算符定义的函数，<code>const foo = () =&gt; &#123;&#125;</code>；</li>
<li>方法：在 class 内定义的函数，<code>class C &#123; foo() &#123;&#125; &#125;</code>；</li>
<li>生成器函数：用 function _ 定义的函数，<code>function_ foo()&#123;&#125;</code>；</li>
<li>类：用 class 定义的类，实际上也是函数，<code>class Foo &#123; constructor() &#123;&#125; &#125;</code>；</li>
<li>异步函数：普通函数、箭头函数和生成器函数加上 async 关键字，</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对普通变量而言，这些函数并没有本质区别，都是遵循了“继承定义时环境”的规则，它们的一个行为差异在于 this 关键字。</p>
<h3 id="this-关键字的行为"><a href="#this-关键字的行为" class="headerlink" title="this 关键字的行为"></a>this 关键字的行为</h3><p><strong>this 是执行上下文中很重要的一个组成部分。同一个函数调用方式不同，得到的 this 值也不同</strong>（this 是运行时，作用域是定义时）。</p>
<h4 id="例-1"><a href="#例-1" class="headerlink" title="例 1"></a><em>例 1</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showThis</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> showThis2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  showThis: showThis,</span><br><span class="line">  showThis2: showThis2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">showThis(); <span class="comment">// global</span></span><br><span class="line">o.showThis(); <span class="comment">// o</span></span><br><span class="line">o.showThis2(); <span class="comment">// global</span></span><br></pre></td></tr></table></figure>

<p>1、</p>
<p>普通函数的 this 值由“调用它所使用的引用”决定（谁调用，指向谁）。</p>
<p>我们获取函数的表达式，它实际上返回的并非函数本身，而是一个 <strong>Reference 类型</strong>。</p>
<p>Reference 类型由两部分组成：一个对象和一个属性值。不难理解<code>o.showThis</code>产生的 Reference 类型，即由对象 o 和属性“showThis”构成。</p>
<p>当做一些算术运算（或者其他运算时），Reference 类型会被解引用，即获取真正的值（被引用的内容）来参与运算，而类似函数调用、delete 等操作，都需要用到 Reference 类型中的对象。</p>
<p>Reference 类型中的对象被当作 this 值，传入了执行函数时的上下文当中。所以对 this 的解释就是：<strong>调用函数时使用的引用，决定了函数执行时刻的 this 值</strong>。</p>
<p>从运行时的角度来看，this 跟面向对象毫无关联，它是与函数调用时使用的表达式相关。</p>
<p>2、</p>
<p>箭头函数实际上是 lambda 表达式，它的返回值是一个函数, 它不是一个语句，所以它产生的函数实际上是计算出来的而不是声明出来的 当然，我们在声明函数的时候也是有计算过程的，不过如果我们使用 function 来声明闭包，那么它的 this 其实是由 this 的绑定规则所决定的 但是如果我们使用 lambda 表达式来计算一个函数，那么它的 this 就取决于 lambda 表达式被计算时的运行环境。</p>
<p>箭头函数的 this 值不会指向外部对象， 其根源是<strong>箭头函数不会产生新的执行上下文</strong>，因此其 this 值将与外层函数保持一致，如果没有外层函数，则为 global。</p>
<p>箭头函数的 this 指向简单来说取决包裹箭头函数的第一个普通函数的 <code>this</code>。</p>
<h4 id="例-2"><a href="#例-2" class="headerlink" title="例 2"></a><em>例 2</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">showThis</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">var</span> showThis = o.showThis;</span><br><span class="line"></span><br><span class="line">showThis(); <span class="comment">// undefined</span></span><br><span class="line">o.showThis(); <span class="comment">// o</span></span><br></pre></td></tr></table></figure>

<p>所以生成器函数、异步生成器函数和异步普通函数跟普通函数行为是一致的，异步箭头函数与箭头函数行为是一致的。</p>
<h3 id="this-关键字的机制"><a href="#this-关键字的机制" class="headerlink" title="this 关键字的机制"></a>this 关键字的机制</h3><p>函数能够引用定义时的变量，如上文分析，函数也能记住定义时的 this，因此，函数内部必定有一个机制来保存这些信息。在 JavaScript 标准中，为函数规定了用来保存定义时上下文的私有属性[[Environment]]。</p>
<p>当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（outer lexical environment）会被设置成函数的[[Environment]]（也就是函数执行时会使用函数定义时的变量（在 [[Environment]] 中）。 如果这个变量不存在，则向外层查找，外层指向哪里仍然取决于函数定义之时，如果定义时外部有函数则指向外部函数，没有函数则指向 global。 函数执行之时，无论是以何种形式被调用（全局 or 嵌套函数），变量都会依照定义时的环境被查找出来。也就是说，定义时的代码结构决定了函数的“变量查找规则”，即“作用域链”）。</p>
<p>即<strong>切换上下文</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在别处(外部文件等)定义了foo：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 foo 能够访问 b（定义时词法环境），却不能访问 a（执行时的词法环境），这就是执行上下文的切换机制了。</p>
<p>JavaScript 用一个栈来管理执行上下文，这个栈中的每一项又包含一个链表。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/250093/1615442641594-c9b94c45-2cc0-461a-9954-2dbe83168bae.jpeg#align=left&display=inline&height=489&margin=%5Bobject%20Object%5D&originHeight=489&originWidth=916&size=0&status=done&style=none&width=916"></p>
<p>当函数调用时，会入栈一个新的执行上下文，函数调用结束时，执行上下文被出栈。</p>
<p>而 this 则是一个更为复杂的机制，JavaScript 标准定义了 <strong>[[thisMode]]</strong> 私有属性。[[thisMode]] 私有属性有三个取值：</p>
<ul>
<li>lexical：表示从上下文中找 this，这对应了箭头函数。</li>
<li>global：表示当 this 为 undefined 时，取全局对象，对应了普通函数。</li>
<li>strict：当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">showThis(); <span class="comment">// Reference中的对象是global</span></span><br><span class="line">(<span class="literal">false</span> || showThis)(); <span class="comment">// Reference由于运算而被解引用，</span></span><br><span class="line"><span class="comment">// 然后触发this机制[[thisMode]]私有属性的global取值</span></span><br></pre></td></tr></table></figure>

<p>方法的行为跟普通函数有差异，恰恰是因为 class 设计成了<strong>默认按 strict 模式执行</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showThis</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  showThis: showThis,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">showThis(); <span class="comment">// undefined，在非严格模式则是global</span></span><br><span class="line">o.showThis(); <span class="comment">// o</span></span><br></pre></td></tr></table></figure>

<p>函数创建新的执行上下文中的词法环境记录时，会根据**[[thisMode]]**来标记新记录的[[ThisBindingStatus]]私有属性。</p>
<p>代码执行遇到 this 时，会逐层检查当前词法环境记录中的[[ThisBindingStatus]]，当找到有 this 的环境记录时获取 this 的值。</p>
<p>所以嵌套的箭头函数中的代码都指向外层 this：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o.foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">o.foo()()(); <span class="comment">// o, o, o</span></span><br></pre></td></tr></table></figure>

<h3 id="操作-this-的内置函数-call-bind-apply"><a href="#操作-this-的内置函数-call-bind-apply" class="headerlink" title="操作 this 的内置函数(call, bind, apply)"></a>操作 this 的内置函数(call, bind, apply)</h3><p>call 和 apply 可以指定函数调用时传入的 this，call 和 apply 作用是一样的，只是传参方式有区别，call 参数是对象+字符串；apply 参数是对象+数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line">foo.call(&#123;&#125;, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// &#123;&#125; 1 2 3</span></span><br><span class="line">foo.apply(o, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// &#123;a: 1&#125; 1 2 3</span></span><br></pre></td></tr></table></figure>

<p>Function.prototype.bind 它可以生成一个绑定过的函数，这个函数的 this 值固定了参数，不是操作在原函数上而是重新生成了一个新函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line">foo.bind(&#123;&#125;, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(); <span class="comment">// &#123;&#125; 1 2 3</span></span><br></pre></td></tr></table></figure>

<p>PS：call、bind 和 apply 用于不接受 this 的函数类型（如箭头、class）都不会报错，但是它们无法实现改变 this ，不过可以实现传参。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>httishere</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://httishere.github.io/2021/03/11/yuque/%E3%80%8C%E5%A4%A7%E5%89%8D%E7%AB%AF%E3%80%8D%E6%89%A7%E8%A1%8C%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/">https://httishere.github.io/2021/03/11/yuque/%E3%80%8C%E5%A4%A7%E5%89%8D%E7%AB%AF%E3%80%8D%E6%89%A7%E8%A1%8C%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2021 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/js/"># js</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/03/11/yuque/%E3%80%8C%E5%A4%A7%E5%89%8D%E7%AB%AF%E3%80%8D%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84JS%EF%BC%9F/">「大前端」面向对象的JS？</a>
            
            
            <a class="next" rel="next" href="/2021/03/08/yuque/%E3%80%8CDaily%E3%80%8Dinterview%20list/">「Daily」interview list</a>
            
        </section>
        
            <div id="gitalk-container"></div>
            <!--
 * @Author: your name
 * @Date: 2021-07-08 11:08:58
 * @LastEditTime: 2021-07-08 11:09:51
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /hexo-yuque-blog/themes/Chic/layout/_partial/gitalk.ejs
-->
<link rel="stylesheet" href="https://unpkg.com/gitalk@latest/dist/gitalk.css">
<script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
<script src="https://priesttomb.github.io/js/md5.min.js"></script>
<script type="text/javascript">
    new Gitalk({
        clientID: 'c61a26564784a9cb16f3',
        clientSecret: '25a391b4405c726bfa417a4d09a8a9d46fd41e12',
        repo: 'httIsHere.github.io',
        owner: 'httishere',
        admin: 'httishere',
        id: md5(location.pathname),
        distractionFreeMode: true
    }).render('gitalk-container')
</script>
        

    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© httishere | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
